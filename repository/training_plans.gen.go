// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package repository

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"jcourse_go/model/po"
)

func newTrainingPlanPO(db *gorm.DB, opts ...gen.DOOption) trainingPlanPO {
	_trainingPlanPO := trainingPlanPO{}

	_trainingPlanPO.trainingPlanPODo.UseDB(db, opts...)
	_trainingPlanPO.trainingPlanPODo.UseModel(&po.TrainingPlanPO{})

	tableName := _trainingPlanPO.trainingPlanPODo.TableName()
	_trainingPlanPO.ALL = field.NewAsterisk(tableName)
	_trainingPlanPO.ID = field.NewInt64(tableName, "id")
	_trainingPlanPO.CreatedAt = field.NewTime(tableName, "created_at")
	_trainingPlanPO.UpdatedAt = field.NewTime(tableName, "updated_at")
	_trainingPlanPO.Degree = field.NewString(tableName, "degree")
	_trainingPlanPO.Major = field.NewString(tableName, "major")
	_trainingPlanPO.Department = field.NewString(tableName, "department")
	_trainingPlanPO.EntryYear = field.NewString(tableName, "entry_year")
	_trainingPlanPO.MajorCode = field.NewString(tableName, "major_code")
	_trainingPlanPO.TotalYear = field.NewInt64(tableName, "total_year")
	_trainingPlanPO.MinCredits = field.NewFloat64(tableName, "min_credits")
	_trainingPlanPO.MajorClass = field.NewString(tableName, "major_class")
	_trainingPlanPO.RatingCount = field.NewInt64(tableName, "rating_count")
	_trainingPlanPO.RatingAvg = field.NewFloat64(tableName, "rating_avg")
	_trainingPlanPO.SearchIndex = field.NewField(tableName, "search_index")
	_trainingPlanPO.BaseCourses = trainingPlanPOHasManyBaseCourses{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("BaseCourses", "po.TrainingPlanCoursePO"),
		BaseCourse: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("BaseCourses.BaseCourse", "po.BaseCoursePO"),
		},
		TrainingPlan: struct {
			field.RelationField
			BaseCourses struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("BaseCourses.TrainingPlan", "po.TrainingPlanPO"),
			BaseCourses: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("BaseCourses.TrainingPlan.BaseCourses", "po.TrainingPlanCoursePO"),
			},
		},
	}

	_trainingPlanPO.fillFieldMap()

	return _trainingPlanPO
}

type trainingPlanPO struct {
	trainingPlanPODo

	ALL         field.Asterisk
	ID          field.Int64
	CreatedAt   field.Time
	UpdatedAt   field.Time
	Degree      field.String
	Major       field.String
	Department  field.String
	EntryYear   field.String
	MajorCode   field.String
	TotalYear   field.Int64
	MinCredits  field.Float64
	MajorClass  field.String
	RatingCount field.Int64
	RatingAvg   field.Float64
	SearchIndex field.Field
	BaseCourses trainingPlanPOHasManyBaseCourses

	fieldMap map[string]field.Expr
}

func (t trainingPlanPO) Table(newTableName string) *trainingPlanPO {
	t.trainingPlanPODo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t trainingPlanPO) As(alias string) *trainingPlanPO {
	t.trainingPlanPODo.DO = *(t.trainingPlanPODo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *trainingPlanPO) updateTableName(table string) *trainingPlanPO {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.CreatedAt = field.NewTime(table, "created_at")
	t.UpdatedAt = field.NewTime(table, "updated_at")
	t.Degree = field.NewString(table, "degree")
	t.Major = field.NewString(table, "major")
	t.Department = field.NewString(table, "department")
	t.EntryYear = field.NewString(table, "entry_year")
	t.MajorCode = field.NewString(table, "major_code")
	t.TotalYear = field.NewInt64(table, "total_year")
	t.MinCredits = field.NewFloat64(table, "min_credits")
	t.MajorClass = field.NewString(table, "major_class")
	t.RatingCount = field.NewInt64(table, "rating_count")
	t.RatingAvg = field.NewFloat64(table, "rating_avg")
	t.SearchIndex = field.NewField(table, "search_index")

	t.fillFieldMap()

	return t
}

func (t *trainingPlanPO) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *trainingPlanPO) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 15)
	t.fieldMap["id"] = t.ID
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
	t.fieldMap["degree"] = t.Degree
	t.fieldMap["major"] = t.Major
	t.fieldMap["department"] = t.Department
	t.fieldMap["entry_year"] = t.EntryYear
	t.fieldMap["major_code"] = t.MajorCode
	t.fieldMap["total_year"] = t.TotalYear
	t.fieldMap["min_credits"] = t.MinCredits
	t.fieldMap["major_class"] = t.MajorClass
	t.fieldMap["rating_count"] = t.RatingCount
	t.fieldMap["rating_avg"] = t.RatingAvg
	t.fieldMap["search_index"] = t.SearchIndex

}

func (t trainingPlanPO) clone(db *gorm.DB) trainingPlanPO {
	t.trainingPlanPODo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t trainingPlanPO) replaceDB(db *gorm.DB) trainingPlanPO {
	t.trainingPlanPODo.ReplaceDB(db)
	return t
}

type trainingPlanPOHasManyBaseCourses struct {
	db *gorm.DB

	field.RelationField

	BaseCourse struct {
		field.RelationField
	}
	TrainingPlan struct {
		field.RelationField
		BaseCourses struct {
			field.RelationField
		}
	}
}

func (a trainingPlanPOHasManyBaseCourses) Where(conds ...field.Expr) *trainingPlanPOHasManyBaseCourses {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a trainingPlanPOHasManyBaseCourses) WithContext(ctx context.Context) *trainingPlanPOHasManyBaseCourses {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a trainingPlanPOHasManyBaseCourses) Session(session *gorm.Session) *trainingPlanPOHasManyBaseCourses {
	a.db = a.db.Session(session)
	return &a
}

func (a trainingPlanPOHasManyBaseCourses) Model(m *po.TrainingPlanPO) *trainingPlanPOHasManyBaseCoursesTx {
	return &trainingPlanPOHasManyBaseCoursesTx{a.db.Model(m).Association(a.Name())}
}

type trainingPlanPOHasManyBaseCoursesTx struct{ tx *gorm.Association }

func (a trainingPlanPOHasManyBaseCoursesTx) Find() (result []*po.TrainingPlanCoursePO, err error) {
	return result, a.tx.Find(&result)
}

func (a trainingPlanPOHasManyBaseCoursesTx) Append(values ...*po.TrainingPlanCoursePO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a trainingPlanPOHasManyBaseCoursesTx) Replace(values ...*po.TrainingPlanCoursePO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a trainingPlanPOHasManyBaseCoursesTx) Delete(values ...*po.TrainingPlanCoursePO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a trainingPlanPOHasManyBaseCoursesTx) Clear() error {
	return a.tx.Clear()
}

func (a trainingPlanPOHasManyBaseCoursesTx) Count() int64 {
	return a.tx.Count()
}

type trainingPlanPODo struct{ gen.DO }

type ITrainingPlanPODo interface {
	gen.SubQuery
	Debug() ITrainingPlanPODo
	WithContext(ctx context.Context) ITrainingPlanPODo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITrainingPlanPODo
	WriteDB() ITrainingPlanPODo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITrainingPlanPODo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITrainingPlanPODo
	Not(conds ...gen.Condition) ITrainingPlanPODo
	Or(conds ...gen.Condition) ITrainingPlanPODo
	Select(conds ...field.Expr) ITrainingPlanPODo
	Where(conds ...gen.Condition) ITrainingPlanPODo
	Order(conds ...field.Expr) ITrainingPlanPODo
	Distinct(cols ...field.Expr) ITrainingPlanPODo
	Omit(cols ...field.Expr) ITrainingPlanPODo
	Join(table schema.Tabler, on ...field.Expr) ITrainingPlanPODo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITrainingPlanPODo
	RightJoin(table schema.Tabler, on ...field.Expr) ITrainingPlanPODo
	Group(cols ...field.Expr) ITrainingPlanPODo
	Having(conds ...gen.Condition) ITrainingPlanPODo
	Limit(limit int) ITrainingPlanPODo
	Offset(offset int) ITrainingPlanPODo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITrainingPlanPODo
	Unscoped() ITrainingPlanPODo
	Create(values ...*po.TrainingPlanPO) error
	CreateInBatches(values []*po.TrainingPlanPO, batchSize int) error
	Save(values ...*po.TrainingPlanPO) error
	First() (*po.TrainingPlanPO, error)
	Take() (*po.TrainingPlanPO, error)
	Last() (*po.TrainingPlanPO, error)
	Find() ([]*po.TrainingPlanPO, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*po.TrainingPlanPO, err error)
	FindInBatches(result *[]*po.TrainingPlanPO, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*po.TrainingPlanPO) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITrainingPlanPODo
	Assign(attrs ...field.AssignExpr) ITrainingPlanPODo
	Joins(fields ...field.RelationField) ITrainingPlanPODo
	Preload(fields ...field.RelationField) ITrainingPlanPODo
	FirstOrInit() (*po.TrainingPlanPO, error)
	FirstOrCreate() (*po.TrainingPlanPO, error)
	FindByPage(offset int, limit int) (result []*po.TrainingPlanPO, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITrainingPlanPODo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t trainingPlanPODo) Debug() ITrainingPlanPODo {
	return t.withDO(t.DO.Debug())
}

func (t trainingPlanPODo) WithContext(ctx context.Context) ITrainingPlanPODo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t trainingPlanPODo) ReadDB() ITrainingPlanPODo {
	return t.Clauses(dbresolver.Read)
}

func (t trainingPlanPODo) WriteDB() ITrainingPlanPODo {
	return t.Clauses(dbresolver.Write)
}

func (t trainingPlanPODo) Session(config *gorm.Session) ITrainingPlanPODo {
	return t.withDO(t.DO.Session(config))
}

func (t trainingPlanPODo) Clauses(conds ...clause.Expression) ITrainingPlanPODo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t trainingPlanPODo) Returning(value interface{}, columns ...string) ITrainingPlanPODo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t trainingPlanPODo) Not(conds ...gen.Condition) ITrainingPlanPODo {
	return t.withDO(t.DO.Not(conds...))
}

func (t trainingPlanPODo) Or(conds ...gen.Condition) ITrainingPlanPODo {
	return t.withDO(t.DO.Or(conds...))
}

func (t trainingPlanPODo) Select(conds ...field.Expr) ITrainingPlanPODo {
	return t.withDO(t.DO.Select(conds...))
}

func (t trainingPlanPODo) Where(conds ...gen.Condition) ITrainingPlanPODo {
	return t.withDO(t.DO.Where(conds...))
}

func (t trainingPlanPODo) Order(conds ...field.Expr) ITrainingPlanPODo {
	return t.withDO(t.DO.Order(conds...))
}

func (t trainingPlanPODo) Distinct(cols ...field.Expr) ITrainingPlanPODo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t trainingPlanPODo) Omit(cols ...field.Expr) ITrainingPlanPODo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t trainingPlanPODo) Join(table schema.Tabler, on ...field.Expr) ITrainingPlanPODo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t trainingPlanPODo) LeftJoin(table schema.Tabler, on ...field.Expr) ITrainingPlanPODo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t trainingPlanPODo) RightJoin(table schema.Tabler, on ...field.Expr) ITrainingPlanPODo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t trainingPlanPODo) Group(cols ...field.Expr) ITrainingPlanPODo {
	return t.withDO(t.DO.Group(cols...))
}

func (t trainingPlanPODo) Having(conds ...gen.Condition) ITrainingPlanPODo {
	return t.withDO(t.DO.Having(conds...))
}

func (t trainingPlanPODo) Limit(limit int) ITrainingPlanPODo {
	return t.withDO(t.DO.Limit(limit))
}

func (t trainingPlanPODo) Offset(offset int) ITrainingPlanPODo {
	return t.withDO(t.DO.Offset(offset))
}

func (t trainingPlanPODo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITrainingPlanPODo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t trainingPlanPODo) Unscoped() ITrainingPlanPODo {
	return t.withDO(t.DO.Unscoped())
}

func (t trainingPlanPODo) Create(values ...*po.TrainingPlanPO) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t trainingPlanPODo) CreateInBatches(values []*po.TrainingPlanPO, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t trainingPlanPODo) Save(values ...*po.TrainingPlanPO) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t trainingPlanPODo) First() (*po.TrainingPlanPO, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*po.TrainingPlanPO), nil
	}
}

func (t trainingPlanPODo) Take() (*po.TrainingPlanPO, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*po.TrainingPlanPO), nil
	}
}

func (t trainingPlanPODo) Last() (*po.TrainingPlanPO, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*po.TrainingPlanPO), nil
	}
}

func (t trainingPlanPODo) Find() ([]*po.TrainingPlanPO, error) {
	result, err := t.DO.Find()
	return result.([]*po.TrainingPlanPO), err
}

func (t trainingPlanPODo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*po.TrainingPlanPO, err error) {
	buf := make([]*po.TrainingPlanPO, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t trainingPlanPODo) FindInBatches(result *[]*po.TrainingPlanPO, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t trainingPlanPODo) Attrs(attrs ...field.AssignExpr) ITrainingPlanPODo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t trainingPlanPODo) Assign(attrs ...field.AssignExpr) ITrainingPlanPODo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t trainingPlanPODo) Joins(fields ...field.RelationField) ITrainingPlanPODo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t trainingPlanPODo) Preload(fields ...field.RelationField) ITrainingPlanPODo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t trainingPlanPODo) FirstOrInit() (*po.TrainingPlanPO, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*po.TrainingPlanPO), nil
	}
}

func (t trainingPlanPODo) FirstOrCreate() (*po.TrainingPlanPO, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*po.TrainingPlanPO), nil
	}
}

func (t trainingPlanPODo) FindByPage(offset int, limit int) (result []*po.TrainingPlanPO, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t trainingPlanPODo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t trainingPlanPODo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t trainingPlanPODo) Delete(models ...*po.TrainingPlanPO) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *trainingPlanPODo) withDO(do gen.Dao) *trainingPlanPODo {
	t.DO = *do.(*gen.DO)
	return t
}

// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package repository

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"jcourse_go/model/po"
)

func newReviewRevisionPO(db *gorm.DB, opts ...gen.DOOption) reviewRevisionPO {
	_reviewRevisionPO := reviewRevisionPO{}

	_reviewRevisionPO.reviewRevisionPODo.UseDB(db, opts...)
	_reviewRevisionPO.reviewRevisionPODo.UseModel(&po.ReviewRevisionPO{})

	tableName := _reviewRevisionPO.reviewRevisionPODo.TableName()
	_reviewRevisionPO.ALL = field.NewAsterisk(tableName)
	_reviewRevisionPO.ID = field.NewInt64(tableName, "id")
	_reviewRevisionPO.CreatedAt = field.NewTime(tableName, "created_at")
	_reviewRevisionPO.ReviewID = field.NewInt64(tableName, "review_id")
	_reviewRevisionPO.UserID = field.NewInt64(tableName, "user_id")
	_reviewRevisionPO.CourseID = field.NewInt64(tableName, "course_id")
	_reviewRevisionPO.Comment = field.NewString(tableName, "comment")
	_reviewRevisionPO.Rating = field.NewInt64(tableName, "rating")
	_reviewRevisionPO.Semester = field.NewString(tableName, "semester")
	_reviewRevisionPO.IsAnonymous = field.NewBool(tableName, "is_anonymous")
	_reviewRevisionPO.Grade = field.NewString(tableName, "grade")
	_reviewRevisionPO.Review = reviewRevisionPOBelongsToReview{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Review", "po.ReviewPO"),
		Course: struct {
			field.RelationField
			MainTeacher struct {
				field.RelationField
				Courses struct {
					field.RelationField
				}
			}
			Categories struct {
				field.RelationField
				Course struct {
					field.RelationField
				}
			}
			OfferedCourses struct {
				field.RelationField
				Course struct {
					field.RelationField
				}
				MainTeacher struct {
					field.RelationField
				}
				OfferedCourseTeacher struct {
					field.RelationField
					Course struct {
						field.RelationField
					}
					OfferedCourse struct {
						field.RelationField
					}
					MainTeacher struct {
						field.RelationField
					}
					Teacher struct {
						field.RelationField
					}
				}
			}
		}{
			RelationField: field.NewRelation("Review.Course", "po.CoursePO"),
			MainTeacher: struct {
				field.RelationField
				Courses struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Review.Course.MainTeacher", "po.TeacherPO"),
				Courses: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Review.Course.MainTeacher.Courses", "po.CoursePO"),
				},
			},
			Categories: struct {
				field.RelationField
				Course struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Review.Course.Categories", "po.CourseCategoryPO"),
				Course: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Review.Course.Categories.Course", "po.CoursePO"),
				},
			},
			OfferedCourses: struct {
				field.RelationField
				Course struct {
					field.RelationField
				}
				MainTeacher struct {
					field.RelationField
				}
				OfferedCourseTeacher struct {
					field.RelationField
					Course struct {
						field.RelationField
					}
					OfferedCourse struct {
						field.RelationField
					}
					MainTeacher struct {
						field.RelationField
					}
					Teacher struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Review.Course.OfferedCourses", "po.OfferedCoursePO"),
				Course: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Review.Course.OfferedCourses.Course", "po.CoursePO"),
				},
				MainTeacher: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Review.Course.OfferedCourses.MainTeacher", "po.TeacherPO"),
				},
				OfferedCourseTeacher: struct {
					field.RelationField
					Course struct {
						field.RelationField
					}
					OfferedCourse struct {
						field.RelationField
					}
					MainTeacher struct {
						field.RelationField
					}
					Teacher struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Review.Course.OfferedCourses.OfferedCourseTeacher", "po.OfferedCourseTeacherPO"),
					Course: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Review.Course.OfferedCourses.OfferedCourseTeacher.Course", "po.CoursePO"),
					},
					OfferedCourse: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Review.Course.OfferedCourses.OfferedCourseTeacher.OfferedCourse", "po.OfferedCoursePO"),
					},
					MainTeacher: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Review.Course.OfferedCourses.OfferedCourseTeacher.MainTeacher", "po.TeacherPO"),
					},
					Teacher: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Review.Course.OfferedCourses.OfferedCourseTeacher.Teacher", "po.TeacherPO"),
					},
				},
			},
		},
		User: struct {
			field.RelationField
			UserPointDetails struct {
				field.RelationField
				User struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("Review.User", "po.UserPO"),
			UserPointDetails: struct {
				field.RelationField
				User struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Review.User.UserPointDetails", "po.UserPointDetailPO"),
				User: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Review.User.UserPointDetails.User", "po.UserPO"),
				},
			},
		},
		Revisions: struct {
			field.RelationField
			Review struct {
				field.RelationField
			}
			User struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Review.Revisions", "po.ReviewRevisionPO"),
			Review: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Review.Revisions.Review", "po.ReviewPO"),
			},
			User: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Review.Revisions.User", "po.UserPO"),
			},
		},
		Reaction: struct {
			field.RelationField
			Review struct {
				field.RelationField
			}
			User struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Review.Reaction", "po.ReviewReactionPO"),
			Review: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Review.Reaction.Review", "po.ReviewPO"),
			},
			User: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Review.Reaction.User", "po.UserPO"),
			},
		},
	}

	_reviewRevisionPO.User = reviewRevisionPOBelongsToUser{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("User", "po.UserPO"),
	}

	_reviewRevisionPO.fillFieldMap()

	return _reviewRevisionPO
}

type reviewRevisionPO struct {
	reviewRevisionPODo

	ALL         field.Asterisk
	ID          field.Int64
	CreatedAt   field.Time
	ReviewID    field.Int64
	UserID      field.Int64
	CourseID    field.Int64
	Comment     field.String
	Rating      field.Int64
	Semester    field.String
	IsAnonymous field.Bool
	Grade       field.String
	Review      reviewRevisionPOBelongsToReview

	User reviewRevisionPOBelongsToUser

	fieldMap map[string]field.Expr
}

func (r reviewRevisionPO) Table(newTableName string) *reviewRevisionPO {
	r.reviewRevisionPODo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r reviewRevisionPO) As(alias string) *reviewRevisionPO {
	r.reviewRevisionPODo.DO = *(r.reviewRevisionPODo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *reviewRevisionPO) updateTableName(table string) *reviewRevisionPO {
	r.ALL = field.NewAsterisk(table)
	r.ID = field.NewInt64(table, "id")
	r.CreatedAt = field.NewTime(table, "created_at")
	r.ReviewID = field.NewInt64(table, "review_id")
	r.UserID = field.NewInt64(table, "user_id")
	r.CourseID = field.NewInt64(table, "course_id")
	r.Comment = field.NewString(table, "comment")
	r.Rating = field.NewInt64(table, "rating")
	r.Semester = field.NewString(table, "semester")
	r.IsAnonymous = field.NewBool(table, "is_anonymous")
	r.Grade = field.NewString(table, "grade")

	r.fillFieldMap()

	return r
}

func (r *reviewRevisionPO) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *reviewRevisionPO) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 12)
	r.fieldMap["id"] = r.ID
	r.fieldMap["created_at"] = r.CreatedAt
	r.fieldMap["review_id"] = r.ReviewID
	r.fieldMap["user_id"] = r.UserID
	r.fieldMap["course_id"] = r.CourseID
	r.fieldMap["comment"] = r.Comment
	r.fieldMap["rating"] = r.Rating
	r.fieldMap["semester"] = r.Semester
	r.fieldMap["is_anonymous"] = r.IsAnonymous
	r.fieldMap["grade"] = r.Grade

}

func (r reviewRevisionPO) clone(db *gorm.DB) reviewRevisionPO {
	r.reviewRevisionPODo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r reviewRevisionPO) replaceDB(db *gorm.DB) reviewRevisionPO {
	r.reviewRevisionPODo.ReplaceDB(db)
	return r
}

type reviewRevisionPOBelongsToReview struct {
	db *gorm.DB

	field.RelationField

	Course struct {
		field.RelationField
		MainTeacher struct {
			field.RelationField
			Courses struct {
				field.RelationField
			}
		}
		Categories struct {
			field.RelationField
			Course struct {
				field.RelationField
			}
		}
		OfferedCourses struct {
			field.RelationField
			Course struct {
				field.RelationField
			}
			MainTeacher struct {
				field.RelationField
			}
			OfferedCourseTeacher struct {
				field.RelationField
				Course struct {
					field.RelationField
				}
				OfferedCourse struct {
					field.RelationField
				}
				MainTeacher struct {
					field.RelationField
				}
				Teacher struct {
					field.RelationField
				}
			}
		}
	}
	User struct {
		field.RelationField
		UserPointDetails struct {
			field.RelationField
			User struct {
				field.RelationField
			}
		}
	}
	Revisions struct {
		field.RelationField
		Review struct {
			field.RelationField
		}
		User struct {
			field.RelationField
		}
	}
	Reaction struct {
		field.RelationField
		Review struct {
			field.RelationField
		}
		User struct {
			field.RelationField
		}
	}
}

func (a reviewRevisionPOBelongsToReview) Where(conds ...field.Expr) *reviewRevisionPOBelongsToReview {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a reviewRevisionPOBelongsToReview) WithContext(ctx context.Context) *reviewRevisionPOBelongsToReview {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a reviewRevisionPOBelongsToReview) Session(session *gorm.Session) *reviewRevisionPOBelongsToReview {
	a.db = a.db.Session(session)
	return &a
}

func (a reviewRevisionPOBelongsToReview) Model(m *po.ReviewRevisionPO) *reviewRevisionPOBelongsToReviewTx {
	return &reviewRevisionPOBelongsToReviewTx{a.db.Model(m).Association(a.Name())}
}

type reviewRevisionPOBelongsToReviewTx struct{ tx *gorm.Association }

func (a reviewRevisionPOBelongsToReviewTx) Find() (result *po.ReviewPO, err error) {
	return result, a.tx.Find(&result)
}

func (a reviewRevisionPOBelongsToReviewTx) Append(values ...*po.ReviewPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a reviewRevisionPOBelongsToReviewTx) Replace(values ...*po.ReviewPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a reviewRevisionPOBelongsToReviewTx) Delete(values ...*po.ReviewPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a reviewRevisionPOBelongsToReviewTx) Clear() error {
	return a.tx.Clear()
}

func (a reviewRevisionPOBelongsToReviewTx) Count() int64 {
	return a.tx.Count()
}

type reviewRevisionPOBelongsToUser struct {
	db *gorm.DB

	field.RelationField
}

func (a reviewRevisionPOBelongsToUser) Where(conds ...field.Expr) *reviewRevisionPOBelongsToUser {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a reviewRevisionPOBelongsToUser) WithContext(ctx context.Context) *reviewRevisionPOBelongsToUser {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a reviewRevisionPOBelongsToUser) Session(session *gorm.Session) *reviewRevisionPOBelongsToUser {
	a.db = a.db.Session(session)
	return &a
}

func (a reviewRevisionPOBelongsToUser) Model(m *po.ReviewRevisionPO) *reviewRevisionPOBelongsToUserTx {
	return &reviewRevisionPOBelongsToUserTx{a.db.Model(m).Association(a.Name())}
}

type reviewRevisionPOBelongsToUserTx struct{ tx *gorm.Association }

func (a reviewRevisionPOBelongsToUserTx) Find() (result *po.UserPO, err error) {
	return result, a.tx.Find(&result)
}

func (a reviewRevisionPOBelongsToUserTx) Append(values ...*po.UserPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a reviewRevisionPOBelongsToUserTx) Replace(values ...*po.UserPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a reviewRevisionPOBelongsToUserTx) Delete(values ...*po.UserPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a reviewRevisionPOBelongsToUserTx) Clear() error {
	return a.tx.Clear()
}

func (a reviewRevisionPOBelongsToUserTx) Count() int64 {
	return a.tx.Count()
}

type reviewRevisionPODo struct{ gen.DO }

type IReviewRevisionPODo interface {
	gen.SubQuery
	Debug() IReviewRevisionPODo
	WithContext(ctx context.Context) IReviewRevisionPODo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IReviewRevisionPODo
	WriteDB() IReviewRevisionPODo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IReviewRevisionPODo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IReviewRevisionPODo
	Not(conds ...gen.Condition) IReviewRevisionPODo
	Or(conds ...gen.Condition) IReviewRevisionPODo
	Select(conds ...field.Expr) IReviewRevisionPODo
	Where(conds ...gen.Condition) IReviewRevisionPODo
	Order(conds ...field.Expr) IReviewRevisionPODo
	Distinct(cols ...field.Expr) IReviewRevisionPODo
	Omit(cols ...field.Expr) IReviewRevisionPODo
	Join(table schema.Tabler, on ...field.Expr) IReviewRevisionPODo
	LeftJoin(table schema.Tabler, on ...field.Expr) IReviewRevisionPODo
	RightJoin(table schema.Tabler, on ...field.Expr) IReviewRevisionPODo
	Group(cols ...field.Expr) IReviewRevisionPODo
	Having(conds ...gen.Condition) IReviewRevisionPODo
	Limit(limit int) IReviewRevisionPODo
	Offset(offset int) IReviewRevisionPODo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IReviewRevisionPODo
	Unscoped() IReviewRevisionPODo
	Create(values ...*po.ReviewRevisionPO) error
	CreateInBatches(values []*po.ReviewRevisionPO, batchSize int) error
	Save(values ...*po.ReviewRevisionPO) error
	First() (*po.ReviewRevisionPO, error)
	Take() (*po.ReviewRevisionPO, error)
	Last() (*po.ReviewRevisionPO, error)
	Find() ([]*po.ReviewRevisionPO, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*po.ReviewRevisionPO, err error)
	FindInBatches(result *[]*po.ReviewRevisionPO, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*po.ReviewRevisionPO) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IReviewRevisionPODo
	Assign(attrs ...field.AssignExpr) IReviewRevisionPODo
	Joins(fields ...field.RelationField) IReviewRevisionPODo
	Preload(fields ...field.RelationField) IReviewRevisionPODo
	FirstOrInit() (*po.ReviewRevisionPO, error)
	FirstOrCreate() (*po.ReviewRevisionPO, error)
	FindByPage(offset int, limit int) (result []*po.ReviewRevisionPO, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IReviewRevisionPODo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r reviewRevisionPODo) Debug() IReviewRevisionPODo {
	return r.withDO(r.DO.Debug())
}

func (r reviewRevisionPODo) WithContext(ctx context.Context) IReviewRevisionPODo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r reviewRevisionPODo) ReadDB() IReviewRevisionPODo {
	return r.Clauses(dbresolver.Read)
}

func (r reviewRevisionPODo) WriteDB() IReviewRevisionPODo {
	return r.Clauses(dbresolver.Write)
}

func (r reviewRevisionPODo) Session(config *gorm.Session) IReviewRevisionPODo {
	return r.withDO(r.DO.Session(config))
}

func (r reviewRevisionPODo) Clauses(conds ...clause.Expression) IReviewRevisionPODo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r reviewRevisionPODo) Returning(value interface{}, columns ...string) IReviewRevisionPODo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r reviewRevisionPODo) Not(conds ...gen.Condition) IReviewRevisionPODo {
	return r.withDO(r.DO.Not(conds...))
}

func (r reviewRevisionPODo) Or(conds ...gen.Condition) IReviewRevisionPODo {
	return r.withDO(r.DO.Or(conds...))
}

func (r reviewRevisionPODo) Select(conds ...field.Expr) IReviewRevisionPODo {
	return r.withDO(r.DO.Select(conds...))
}

func (r reviewRevisionPODo) Where(conds ...gen.Condition) IReviewRevisionPODo {
	return r.withDO(r.DO.Where(conds...))
}

func (r reviewRevisionPODo) Order(conds ...field.Expr) IReviewRevisionPODo {
	return r.withDO(r.DO.Order(conds...))
}

func (r reviewRevisionPODo) Distinct(cols ...field.Expr) IReviewRevisionPODo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r reviewRevisionPODo) Omit(cols ...field.Expr) IReviewRevisionPODo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r reviewRevisionPODo) Join(table schema.Tabler, on ...field.Expr) IReviewRevisionPODo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r reviewRevisionPODo) LeftJoin(table schema.Tabler, on ...field.Expr) IReviewRevisionPODo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r reviewRevisionPODo) RightJoin(table schema.Tabler, on ...field.Expr) IReviewRevisionPODo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r reviewRevisionPODo) Group(cols ...field.Expr) IReviewRevisionPODo {
	return r.withDO(r.DO.Group(cols...))
}

func (r reviewRevisionPODo) Having(conds ...gen.Condition) IReviewRevisionPODo {
	return r.withDO(r.DO.Having(conds...))
}

func (r reviewRevisionPODo) Limit(limit int) IReviewRevisionPODo {
	return r.withDO(r.DO.Limit(limit))
}

func (r reviewRevisionPODo) Offset(offset int) IReviewRevisionPODo {
	return r.withDO(r.DO.Offset(offset))
}

func (r reviewRevisionPODo) Scopes(funcs ...func(gen.Dao) gen.Dao) IReviewRevisionPODo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r reviewRevisionPODo) Unscoped() IReviewRevisionPODo {
	return r.withDO(r.DO.Unscoped())
}

func (r reviewRevisionPODo) Create(values ...*po.ReviewRevisionPO) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r reviewRevisionPODo) CreateInBatches(values []*po.ReviewRevisionPO, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r reviewRevisionPODo) Save(values ...*po.ReviewRevisionPO) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r reviewRevisionPODo) First() (*po.ReviewRevisionPO, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*po.ReviewRevisionPO), nil
	}
}

func (r reviewRevisionPODo) Take() (*po.ReviewRevisionPO, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*po.ReviewRevisionPO), nil
	}
}

func (r reviewRevisionPODo) Last() (*po.ReviewRevisionPO, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*po.ReviewRevisionPO), nil
	}
}

func (r reviewRevisionPODo) Find() ([]*po.ReviewRevisionPO, error) {
	result, err := r.DO.Find()
	return result.([]*po.ReviewRevisionPO), err
}

func (r reviewRevisionPODo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*po.ReviewRevisionPO, err error) {
	buf := make([]*po.ReviewRevisionPO, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r reviewRevisionPODo) FindInBatches(result *[]*po.ReviewRevisionPO, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r reviewRevisionPODo) Attrs(attrs ...field.AssignExpr) IReviewRevisionPODo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r reviewRevisionPODo) Assign(attrs ...field.AssignExpr) IReviewRevisionPODo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r reviewRevisionPODo) Joins(fields ...field.RelationField) IReviewRevisionPODo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r reviewRevisionPODo) Preload(fields ...field.RelationField) IReviewRevisionPODo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r reviewRevisionPODo) FirstOrInit() (*po.ReviewRevisionPO, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*po.ReviewRevisionPO), nil
	}
}

func (r reviewRevisionPODo) FirstOrCreate() (*po.ReviewRevisionPO, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*po.ReviewRevisionPO), nil
	}
}

func (r reviewRevisionPODo) FindByPage(offset int, limit int) (result []*po.ReviewRevisionPO, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r reviewRevisionPODo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r reviewRevisionPODo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r reviewRevisionPODo) Delete(models ...*po.ReviewRevisionPO) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *reviewRevisionPODo) withDO(do gen.Dao) *reviewRevisionPODo {
	r.DO = *do.(*gen.DO)
	return r
}

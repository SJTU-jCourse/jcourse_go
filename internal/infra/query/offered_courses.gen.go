// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"jcourse_go/model/po"
)

func newOfferedCoursePO(db *gorm.DB, opts ...gen.DOOption) offeredCoursePO {
	_offeredCoursePO := offeredCoursePO{}

	_offeredCoursePO.offeredCoursePODo.UseDB(db, opts...)
	_offeredCoursePO.offeredCoursePODo.UseModel(&po.OfferedCoursePO{})

	tableName := _offeredCoursePO.offeredCoursePODo.TableName()
	_offeredCoursePO.ALL = field.NewAsterisk(tableName)
	_offeredCoursePO.ID = field.NewInt64(tableName, "id")
	_offeredCoursePO.CreatedAt = field.NewTime(tableName, "created_at")
	_offeredCoursePO.CourseID = field.NewInt64(tableName, "course_id")
	_offeredCoursePO.MainTeacherID = field.NewInt64(tableName, "main_teacher_id")
	_offeredCoursePO.Semester = field.NewString(tableName, "semester")
	_offeredCoursePO.Language = field.NewString(tableName, "language")
	_offeredCoursePO.Grade = field.NewString(tableName, "grade")
	_offeredCoursePO.OfferedCourseTeacher = offeredCoursePOHasManyOfferedCourseTeacher{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("OfferedCourseTeacher", "po.OfferedCourseTeacherPO"),
		Course: struct {
			field.RelationField
			MainTeacher struct {
				field.RelationField
				Courses struct {
					field.RelationField
				}
			}
			Categories struct {
				field.RelationField
				Course struct {
					field.RelationField
				}
			}
			OfferedCourses struct {
				field.RelationField
				Course struct {
					field.RelationField
				}
				MainTeacher struct {
					field.RelationField
				}
				OfferedCourseTeacher struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("OfferedCourseTeacher.Course", "po.CoursePO"),
			MainTeacher: struct {
				field.RelationField
				Courses struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("OfferedCourseTeacher.Course.MainTeacher", "po.TeacherPO"),
				Courses: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("OfferedCourseTeacher.Course.MainTeacher.Courses", "po.CoursePO"),
				},
			},
			Categories: struct {
				field.RelationField
				Course struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("OfferedCourseTeacher.Course.Categories", "po.CourseCategoryPO"),
				Course: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("OfferedCourseTeacher.Course.Categories.Course", "po.CoursePO"),
				},
			},
			OfferedCourses: struct {
				field.RelationField
				Course struct {
					field.RelationField
				}
				MainTeacher struct {
					field.RelationField
				}
				OfferedCourseTeacher struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("OfferedCourseTeacher.Course.OfferedCourses", "po.OfferedCoursePO"),
				Course: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("OfferedCourseTeacher.Course.OfferedCourses.Course", "po.CoursePO"),
				},
				MainTeacher: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("OfferedCourseTeacher.Course.OfferedCourses.MainTeacher", "po.TeacherPO"),
				},
				OfferedCourseTeacher: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("OfferedCourseTeacher.Course.OfferedCourses.OfferedCourseTeacher", "po.OfferedCourseTeacherPO"),
				},
			},
		},
		OfferedCourse: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("OfferedCourseTeacher.OfferedCourse", "po.OfferedCoursePO"),
		},
		MainTeacher: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("OfferedCourseTeacher.MainTeacher", "po.TeacherPO"),
		},
		Teacher: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("OfferedCourseTeacher.Teacher", "po.TeacherPO"),
		},
	}

	_offeredCoursePO.Course = offeredCoursePOBelongsToCourse{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Course", "po.CoursePO"),
	}

	_offeredCoursePO.MainTeacher = offeredCoursePOBelongsToMainTeacher{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("MainTeacher", "po.TeacherPO"),
	}

	_offeredCoursePO.fillFieldMap()

	return _offeredCoursePO
}

type offeredCoursePO struct {
	offeredCoursePODo

	ALL                  field.Asterisk
	ID                   field.Int64
	CreatedAt            field.Time
	CourseID             field.Int64
	MainTeacherID        field.Int64
	Semester             field.String
	Language             field.String
	Grade                field.String
	OfferedCourseTeacher offeredCoursePOHasManyOfferedCourseTeacher

	Course offeredCoursePOBelongsToCourse

	MainTeacher offeredCoursePOBelongsToMainTeacher

	fieldMap map[string]field.Expr
}

func (o offeredCoursePO) Table(newTableName string) *offeredCoursePO {
	o.offeredCoursePODo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o offeredCoursePO) As(alias string) *offeredCoursePO {
	o.offeredCoursePODo.DO = *(o.offeredCoursePODo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *offeredCoursePO) updateTableName(table string) *offeredCoursePO {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewInt64(table, "id")
	o.CreatedAt = field.NewTime(table, "created_at")
	o.CourseID = field.NewInt64(table, "course_id")
	o.MainTeacherID = field.NewInt64(table, "main_teacher_id")
	o.Semester = field.NewString(table, "semester")
	o.Language = field.NewString(table, "language")
	o.Grade = field.NewString(table, "grade")

	o.fillFieldMap()

	return o
}

func (o *offeredCoursePO) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *offeredCoursePO) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 10)
	o.fieldMap["id"] = o.ID
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["course_id"] = o.CourseID
	o.fieldMap["main_teacher_id"] = o.MainTeacherID
	o.fieldMap["semester"] = o.Semester
	o.fieldMap["language"] = o.Language
	o.fieldMap["grade"] = o.Grade

}

func (o offeredCoursePO) clone(db *gorm.DB) offeredCoursePO {
	o.offeredCoursePODo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o offeredCoursePO) replaceDB(db *gorm.DB) offeredCoursePO {
	o.offeredCoursePODo.ReplaceDB(db)
	return o
}

type offeredCoursePOHasManyOfferedCourseTeacher struct {
	db *gorm.DB

	field.RelationField

	Course struct {
		field.RelationField
		MainTeacher struct {
			field.RelationField
			Courses struct {
				field.RelationField
			}
		}
		Categories struct {
			field.RelationField
			Course struct {
				field.RelationField
			}
		}
		OfferedCourses struct {
			field.RelationField
			Course struct {
				field.RelationField
			}
			MainTeacher struct {
				field.RelationField
			}
			OfferedCourseTeacher struct {
				field.RelationField
			}
		}
	}
	OfferedCourse struct {
		field.RelationField
	}
	MainTeacher struct {
		field.RelationField
	}
	Teacher struct {
		field.RelationField
	}
}

func (a offeredCoursePOHasManyOfferedCourseTeacher) Where(conds ...field.Expr) *offeredCoursePOHasManyOfferedCourseTeacher {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a offeredCoursePOHasManyOfferedCourseTeacher) WithContext(ctx context.Context) *offeredCoursePOHasManyOfferedCourseTeacher {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a offeredCoursePOHasManyOfferedCourseTeacher) Session(session *gorm.Session) *offeredCoursePOHasManyOfferedCourseTeacher {
	a.db = a.db.Session(session)
	return &a
}

func (a offeredCoursePOHasManyOfferedCourseTeacher) Model(m *po.OfferedCoursePO) *offeredCoursePOHasManyOfferedCourseTeacherTx {
	return &offeredCoursePOHasManyOfferedCourseTeacherTx{a.db.Model(m).Association(a.Name())}
}

type offeredCoursePOHasManyOfferedCourseTeacherTx struct{ tx *gorm.Association }

func (a offeredCoursePOHasManyOfferedCourseTeacherTx) Find() (result []*po.OfferedCourseTeacherPO, err error) {
	return result, a.tx.Find(&result)
}

func (a offeredCoursePOHasManyOfferedCourseTeacherTx) Append(values ...*po.OfferedCourseTeacherPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a offeredCoursePOHasManyOfferedCourseTeacherTx) Replace(values ...*po.OfferedCourseTeacherPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a offeredCoursePOHasManyOfferedCourseTeacherTx) Delete(values ...*po.OfferedCourseTeacherPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a offeredCoursePOHasManyOfferedCourseTeacherTx) Clear() error {
	return a.tx.Clear()
}

func (a offeredCoursePOHasManyOfferedCourseTeacherTx) Count() int64 {
	return a.tx.Count()
}

type offeredCoursePOBelongsToCourse struct {
	db *gorm.DB

	field.RelationField
}

func (a offeredCoursePOBelongsToCourse) Where(conds ...field.Expr) *offeredCoursePOBelongsToCourse {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a offeredCoursePOBelongsToCourse) WithContext(ctx context.Context) *offeredCoursePOBelongsToCourse {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a offeredCoursePOBelongsToCourse) Session(session *gorm.Session) *offeredCoursePOBelongsToCourse {
	a.db = a.db.Session(session)
	return &a
}

func (a offeredCoursePOBelongsToCourse) Model(m *po.OfferedCoursePO) *offeredCoursePOBelongsToCourseTx {
	return &offeredCoursePOBelongsToCourseTx{a.db.Model(m).Association(a.Name())}
}

type offeredCoursePOBelongsToCourseTx struct{ tx *gorm.Association }

func (a offeredCoursePOBelongsToCourseTx) Find() (result *po.CoursePO, err error) {
	return result, a.tx.Find(&result)
}

func (a offeredCoursePOBelongsToCourseTx) Append(values ...*po.CoursePO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a offeredCoursePOBelongsToCourseTx) Replace(values ...*po.CoursePO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a offeredCoursePOBelongsToCourseTx) Delete(values ...*po.CoursePO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a offeredCoursePOBelongsToCourseTx) Clear() error {
	return a.tx.Clear()
}

func (a offeredCoursePOBelongsToCourseTx) Count() int64 {
	return a.tx.Count()
}

type offeredCoursePOBelongsToMainTeacher struct {
	db *gorm.DB

	field.RelationField
}

func (a offeredCoursePOBelongsToMainTeacher) Where(conds ...field.Expr) *offeredCoursePOBelongsToMainTeacher {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a offeredCoursePOBelongsToMainTeacher) WithContext(ctx context.Context) *offeredCoursePOBelongsToMainTeacher {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a offeredCoursePOBelongsToMainTeacher) Session(session *gorm.Session) *offeredCoursePOBelongsToMainTeacher {
	a.db = a.db.Session(session)
	return &a
}

func (a offeredCoursePOBelongsToMainTeacher) Model(m *po.OfferedCoursePO) *offeredCoursePOBelongsToMainTeacherTx {
	return &offeredCoursePOBelongsToMainTeacherTx{a.db.Model(m).Association(a.Name())}
}

type offeredCoursePOBelongsToMainTeacherTx struct{ tx *gorm.Association }

func (a offeredCoursePOBelongsToMainTeacherTx) Find() (result *po.TeacherPO, err error) {
	return result, a.tx.Find(&result)
}

func (a offeredCoursePOBelongsToMainTeacherTx) Append(values ...*po.TeacherPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a offeredCoursePOBelongsToMainTeacherTx) Replace(values ...*po.TeacherPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a offeredCoursePOBelongsToMainTeacherTx) Delete(values ...*po.TeacherPO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a offeredCoursePOBelongsToMainTeacherTx) Clear() error {
	return a.tx.Clear()
}

func (a offeredCoursePOBelongsToMainTeacherTx) Count() int64 {
	return a.tx.Count()
}

type offeredCoursePODo struct{ gen.DO }

type IOfferedCoursePODo interface {
	gen.SubQuery
	Debug() IOfferedCoursePODo
	WithContext(ctx context.Context) IOfferedCoursePODo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOfferedCoursePODo
	WriteDB() IOfferedCoursePODo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOfferedCoursePODo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOfferedCoursePODo
	Not(conds ...gen.Condition) IOfferedCoursePODo
	Or(conds ...gen.Condition) IOfferedCoursePODo
	Select(conds ...field.Expr) IOfferedCoursePODo
	Where(conds ...gen.Condition) IOfferedCoursePODo
	Order(conds ...field.Expr) IOfferedCoursePODo
	Distinct(cols ...field.Expr) IOfferedCoursePODo
	Omit(cols ...field.Expr) IOfferedCoursePODo
	Join(table schema.Tabler, on ...field.Expr) IOfferedCoursePODo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOfferedCoursePODo
	RightJoin(table schema.Tabler, on ...field.Expr) IOfferedCoursePODo
	Group(cols ...field.Expr) IOfferedCoursePODo
	Having(conds ...gen.Condition) IOfferedCoursePODo
	Limit(limit int) IOfferedCoursePODo
	Offset(offset int) IOfferedCoursePODo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOfferedCoursePODo
	Unscoped() IOfferedCoursePODo
	Create(values ...*po.OfferedCoursePO) error
	CreateInBatches(values []*po.OfferedCoursePO, batchSize int) error
	Save(values ...*po.OfferedCoursePO) error
	First() (*po.OfferedCoursePO, error)
	Take() (*po.OfferedCoursePO, error)
	Last() (*po.OfferedCoursePO, error)
	Find() ([]*po.OfferedCoursePO, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*po.OfferedCoursePO, err error)
	FindInBatches(result *[]*po.OfferedCoursePO, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*po.OfferedCoursePO) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOfferedCoursePODo
	Assign(attrs ...field.AssignExpr) IOfferedCoursePODo
	Joins(fields ...field.RelationField) IOfferedCoursePODo
	Preload(fields ...field.RelationField) IOfferedCoursePODo
	FirstOrInit() (*po.OfferedCoursePO, error)
	FirstOrCreate() (*po.OfferedCoursePO, error)
	FindByPage(offset int, limit int) (result []*po.OfferedCoursePO, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOfferedCoursePODo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o offeredCoursePODo) Debug() IOfferedCoursePODo {
	return o.withDO(o.DO.Debug())
}

func (o offeredCoursePODo) WithContext(ctx context.Context) IOfferedCoursePODo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o offeredCoursePODo) ReadDB() IOfferedCoursePODo {
	return o.Clauses(dbresolver.Read)
}

func (o offeredCoursePODo) WriteDB() IOfferedCoursePODo {
	return o.Clauses(dbresolver.Write)
}

func (o offeredCoursePODo) Session(config *gorm.Session) IOfferedCoursePODo {
	return o.withDO(o.DO.Session(config))
}

func (o offeredCoursePODo) Clauses(conds ...clause.Expression) IOfferedCoursePODo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o offeredCoursePODo) Returning(value interface{}, columns ...string) IOfferedCoursePODo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o offeredCoursePODo) Not(conds ...gen.Condition) IOfferedCoursePODo {
	return o.withDO(o.DO.Not(conds...))
}

func (o offeredCoursePODo) Or(conds ...gen.Condition) IOfferedCoursePODo {
	return o.withDO(o.DO.Or(conds...))
}

func (o offeredCoursePODo) Select(conds ...field.Expr) IOfferedCoursePODo {
	return o.withDO(o.DO.Select(conds...))
}

func (o offeredCoursePODo) Where(conds ...gen.Condition) IOfferedCoursePODo {
	return o.withDO(o.DO.Where(conds...))
}

func (o offeredCoursePODo) Order(conds ...field.Expr) IOfferedCoursePODo {
	return o.withDO(o.DO.Order(conds...))
}

func (o offeredCoursePODo) Distinct(cols ...field.Expr) IOfferedCoursePODo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o offeredCoursePODo) Omit(cols ...field.Expr) IOfferedCoursePODo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o offeredCoursePODo) Join(table schema.Tabler, on ...field.Expr) IOfferedCoursePODo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o offeredCoursePODo) LeftJoin(table schema.Tabler, on ...field.Expr) IOfferedCoursePODo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o offeredCoursePODo) RightJoin(table schema.Tabler, on ...field.Expr) IOfferedCoursePODo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o offeredCoursePODo) Group(cols ...field.Expr) IOfferedCoursePODo {
	return o.withDO(o.DO.Group(cols...))
}

func (o offeredCoursePODo) Having(conds ...gen.Condition) IOfferedCoursePODo {
	return o.withDO(o.DO.Having(conds...))
}

func (o offeredCoursePODo) Limit(limit int) IOfferedCoursePODo {
	return o.withDO(o.DO.Limit(limit))
}

func (o offeredCoursePODo) Offset(offset int) IOfferedCoursePODo {
	return o.withDO(o.DO.Offset(offset))
}

func (o offeredCoursePODo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOfferedCoursePODo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o offeredCoursePODo) Unscoped() IOfferedCoursePODo {
	return o.withDO(o.DO.Unscoped())
}

func (o offeredCoursePODo) Create(values ...*po.OfferedCoursePO) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o offeredCoursePODo) CreateInBatches(values []*po.OfferedCoursePO, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o offeredCoursePODo) Save(values ...*po.OfferedCoursePO) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o offeredCoursePODo) First() (*po.OfferedCoursePO, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*po.OfferedCoursePO), nil
	}
}

func (o offeredCoursePODo) Take() (*po.OfferedCoursePO, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*po.OfferedCoursePO), nil
	}
}

func (o offeredCoursePODo) Last() (*po.OfferedCoursePO, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*po.OfferedCoursePO), nil
	}
}

func (o offeredCoursePODo) Find() ([]*po.OfferedCoursePO, error) {
	result, err := o.DO.Find()
	return result.([]*po.OfferedCoursePO), err
}

func (o offeredCoursePODo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*po.OfferedCoursePO, err error) {
	buf := make([]*po.OfferedCoursePO, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o offeredCoursePODo) FindInBatches(result *[]*po.OfferedCoursePO, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o offeredCoursePODo) Attrs(attrs ...field.AssignExpr) IOfferedCoursePODo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o offeredCoursePODo) Assign(attrs ...field.AssignExpr) IOfferedCoursePODo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o offeredCoursePODo) Joins(fields ...field.RelationField) IOfferedCoursePODo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o offeredCoursePODo) Preload(fields ...field.RelationField) IOfferedCoursePODo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o offeredCoursePODo) FirstOrInit() (*po.OfferedCoursePO, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*po.OfferedCoursePO), nil
	}
}

func (o offeredCoursePODo) FirstOrCreate() (*po.OfferedCoursePO, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*po.OfferedCoursePO), nil
	}
}

func (o offeredCoursePODo) FindByPage(offset int, limit int) (result []*po.OfferedCoursePO, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o offeredCoursePODo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o offeredCoursePODo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o offeredCoursePODo) Delete(models ...*po.OfferedCoursePO) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *offeredCoursePODo) withDO(do gen.Dao) *offeredCoursePODo {
	o.DO = *do.(*gen.DO)
	return o
}

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

// 定义模板，用于生成方法
const tmpl = `// Code generated by codegen.go; DO NOT EDIT.

package types

// {{.TypeName}} 相关方法

// IsA{{.TypeName}} 判断值是否属于 {{.TypeName}} 类型
func IsA{{.TypeName}}(s string) bool {
	switch s {
	{{- range .Values }}
	case "{{.}}":
		return true
	{{- end }}
	default:
		return false
	}
}

// Values 返回所有 {{.TypeName}} 的值
func (t {{.TypeName}}) Values() []string {
	return []string{
		{{- range .Values }}
		"{{.}}",
		{{- end }}
	}
}

// String 返回 {{.TypeName}} 的字符串表示
func (t {{.TypeName}}) String() string {
	return string(t)
}
`

type TypeInfo struct {
	TypeName string
	Values   []string
}

func main() {
	// 定义命令行标志
	typeFlag := flag.String("type", "", "要生成代码的类型名称 (可多个，用逗号分隔)")
	fileFlag := flag.String("file", "", "类型定义文件的路径")
	flag.Parse()

	if *typeFlag == "" {
		log.Fatalf("请通过 -type 标志指定要生成代码的类型名称")
	}

	if *fileFlag == "" {
		log.Fatalf("请通过 -file 标志指定类型定义文件的路径")
	}

	types := strings.Split(*typeFlag, ",")

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, *fileFlag, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("无法解析文件: %v", err)
	}

	var typesInfo []TypeInfo

	for _, typename := range types {
		var typeName = strings.TrimSpace(typename)
		var values []string

		// 查找类型定义
		found := false
		for _, decl := range node.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok || typeSpec.Name.Name != typeName {
					continue
				}

				// 确认类型为 string 类型别名
				_, ok = typeSpec.Type.(*ast.Ident)
				if !ok {
					continue
				}

				found = true
				break
			}
		}

		if !found {
			log.Printf("类型 %s 未找到或不是 string 类型别名，跳过", typeName)
			continue
		}

		// 查找常量
		for _, decl := range node.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.CONST {
				continue
			}

			for _, s := range gen.Specs {
				valSpec, ok := s.(*ast.ValueSpec)
				if !ok {
					continue
				}

				ident, ok := valSpec.Type.(*ast.Ident)
				if !ok || ident.Name != typeName {
					continue
				}

				for _, v := range valSpec.Values {
					if bl, ok := v.(*ast.BasicLit); ok && bl.Kind == token.STRING {
						value := strings.Trim(bl.Value, `"`)
						values = append(values, value)
					}
				}
			}
		}

		if len(values) == 0 {
			log.Printf("类型 %s 没有找到对应的常量值，跳过", typeName)
			continue
		}

		typesInfo = append(typesInfo, TypeInfo{
			TypeName: typeName,
			Values:   values,
		})
	}

	if len(typesInfo) == 0 {
		log.Fatalf("没有找到需要生成代码的类型")
	}

	t := template.Must(template.New("codegen").Parse(tmpl))

	for _, typeInfo := range typesInfo {
		var buf bytes.Buffer
		err := t.Execute(&buf, typeInfo)
		if err != nil {
			log.Fatalf("模板执行失败: %v", err)
		}

		// 生成文件名，例如 rating_related_type_gen.go
		fileName := fmt.Sprintf("%s_gen.go", toSnakeCase(typeInfo.TypeName))
		err = os.WriteFile(fileName, buf.Bytes(), 0644)
		if err != nil {
			log.Fatalf("无法写入文件 %s: %v", fileName, err)
		}

		fmt.Printf("生成文件: %s\n", fileName)
	}
}

// toSnakeCase 将驼峰命名转换为蛇形命名
func toSnakeCase(str string) string {
	var result []rune
	for i, r := range str {
		if i > 0 && 'A' <= r && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}
